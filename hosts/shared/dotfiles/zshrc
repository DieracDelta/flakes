# control-v no longer makes weird character
# and instant paste
if [ -n "${commands[fzf-share]}" ]; then
  source "$(fzf-share)/key-bindings.zsh"
  source "$(fzf-share)/completion.zsh"
fi

pasteinit() {
  OLD_SELF_INSERT=${${(s.:.)widgets[self-insert]}[2,3]}
  zle -N self-insert url-quote-magic
}

pastefinish() {
  zle -N self-insert $OLD_SELF_INSERT
}

zstyle :bracketed-paste-magic paste-init pasteinit
zstyle :bracketed-paste-magic paste-finish pastefinish

bindkey -r ^V

# ansi escape for man pages; stolen shamelessly from gytis
export LESS_TERMCAP_mb=$'\e[1;33m'
export LESS_TERMCAP_md=$'\e[1;33m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;33m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;4;32m'

export _JAVA_AWT_WM_NONREPARENTING=1
# for colors
#cat $HOME/.cache/wal/sequences
function post_code {
        INPUT_UNESCAPED=$(cat)
        INPUT=''${INPUT_UNESCAPED//\\/\\\\}
        echo -n "https://endpoints.justinrestivo.me/"$(echo -n '{"key":"'$ENDPOINTKEY'","src":"' $(echo $INPUT | base64) '"}' | curl -X POST https://endpoints.justinrestivo.me/code -H 'Content-Type: application/json' --data @- | jq -r '.link') | wl-copy
}
function scp_mits_color {
        ssh -f -N -l $KERBEROS athena.dialup.mit.edu
        ssh $KERBEROS@athena.dialup.mit.edu "mkdir printer_files"
        cmd=""
        for var in "$@"
        do
                #cmd+="lpr -P mitprint -U graceyin -o sides=two-sided-long-edge ~/printer_files/"
                # add -# 20 to print 20 copies
                #cmd+="lpr -P mitprint-color -o sides=two-sided-long-edge ~/printer_files/"
                cmd+="lpr -P mitprint-color -o sides=two-sided-long-edge ~/printer_files/"
                #cmd+="lpr -P mitprint ~/printer_files/"
                #cmd+="lpr -P mitprint ~/printer_files/"
                cmd+=$(basename $var)
                cmd+="; "
        done
        echo $cmd
        scp $@ $KERBEROS@athena.dialup.mit.edu:/mit/$KERBEROS/printer_files/
        ssh $KERBEROS@athena.dialup.mit.edu $cmd " rm -dr printer_files"
}

# double sided
function scp_mit {
        ssh -f -N -l $KERBEROS athena.dialup.mit.edu
        ssh $KERBEROS@athena.dialup.mit.edu "mkdir printer_files"
        cmd=""
        for var in "$@"
        do
                #cmd+="lpr -P mitprint -U graceyin -o sides=two-sided-long-edge ~/printer_files/"
                # add -# 20 to print 20 copies
                cmd+="lpr -P mitprint-color -o sides=two-sided-long-edge ~/printer_files/"
                cmd+="lpr -P mitprint -o sides=two-sided-long-edge ~/printer_files/"
                #cmd+="lpr -P mitprint -o ~/printer_files/"
                #cmd+="lpr -P mitprint ~/printer_files/"
                #cmd+="lpr -P mitprint ~/printer_files/"
                cmd+=$(basename $var)
                cmd+="; "
        done
        echo $cmd
        scp $@ $KERBEROS@athena.dialup.mit.edu:/mit/$KERBEROS/printer_files/
        ssh $KERBEROS@athena.dialup.mit.edu $cmd " rm -dr printer_files"
}

MAIM_LOCATION="/tmp/maim_screenshoot.png"

function post_image {
        grim -g "$(slurp)" -t "png" $MAIM_LOCATION
        echo -n "https://endpoints.justinrestivo.me/"$(echo -n '{"key": "'$ENDPOINTKEY'", "doCasify" : false, "src":"data:image/jpg;base64,'$(base64 -i $MAIM_LOCATION)'"}' | curl -X POST https://endpoints.justinrestivo.me/image -H 'Content-Type: application/json' --data @- | jq -r '.link' )  | wl-copy
}

function post_image_rust {
        ENDPOINTKEY_2="THIS_IS_A_KEY"
        grim -g "$(slurp)" -t "png" $MAIM_LOCATION
        echo -n "localhost:8000/image/view/"$(echo -n '{"key": "'$ENDPOINTKEY_2'", "src":"'$(base64 -i $MAIM_LOCATION)'"}' | curl -X POST localhost:8000/image/post -H 'Content-Type: application/json' --data @- | jq -r '.link' )  | wl-copy
}

function post_code_rust {
        ENDPOINTKEY_2="THIS_IS_A_KEY"
        INPUT_UNESCAPED=$(cat)
        INPUT=''${INPUT_UNESCAPED//\\/\\\\}
        echo -n "localhost:8000/code/view/"$(echo -n '{"key":"'$ENDPOINTKEY_2'","src":"'$(echo $INPUT | base64)'"}' | curl -X POST localhost:8000/code/post -H 'Content-Type: application/json' --data @- | jq -r '.link') | wl-copy
}

export FZF_COMPLETION_TRIGGER='~~'

# Use fd (https://github.com/sharkdp/fd) instead of the default find
# command for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversal
# - See the source code (completion.{bash,zsh}) for the details.
_fzf_compgen_path() {
        fd --hidden --follow --exclude ".git" . "$1"
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
        fd --type d --hidden --follow --exclude ".git" . "$1"
}

if [ -n "''${commands[fzf-share]}" ]; then
        source "$(fzf-share)/key-bindings.zsh"
fi

# Select a running docker container to stop
function ds() {
        local cid
        cid=$(docker ps | sed 1d | fzf -q "$1" | awk '{print $1}')

        [ -n "$cid" ] && docker stop "$cid"
}
# Select a docker container to remove
function drm() {
        local cid
        cid=$(docker ps -a | sed 1d | fzf -q "$1" | awk '{print $1}')

        [ -n "$cid" ] && docker rm "$cid"
}
# Select a container to attach onto with bash
function da() {
        local cid
        cid=$(docker ps -a | sed 1d | fzf -q "$1" | awk '{print $1}')

        [ -n "$cid" ] && docker container exec -it "$cid" /bin/bash
}
# nix direnv hook
eval "$(direnv hook zsh)"
eval $(opam env)

function _nix() {
  local ifs_bk="$IFS"
  local input=("${(Q)words[@]}")
  IFS=$'\n'
  local res=($(NIX_GET_COMPLETIONS=$((CURRENT - 1)) "$input[@]"))
  IFS="$ifs_bk"
  local tpe="${${res[1]}%%>	*}"
  local -a suggestions
  declare -a suggestions
  for suggestion in ${res:1}; do
    # FIXME: This doesn't work properly if the suggestion word contains a `:`
    # itself
    suggestions+="${suggestion/	/:}"
  done
  if [[ "$tpe" == filenames ]]; then
    compadd -f
  fi
  _describe 'nix' suggestions
}

compdef _nix nix
